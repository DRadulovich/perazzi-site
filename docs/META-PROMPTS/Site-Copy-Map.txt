Task Card: Frontend Copy Map for a Single Page

1. Context

You are working inside a Next.js + React + Sanity codebase for the Perazzi site.

Your job is to analyze a single page (one route) and produce a structured map of all user-facing text that appears on that page:
	•	Where it comes from (exact source and location).
	•	What the text is (literal value, or as close as can be determined from fixtures/fallbacks).
	•	How it is wired (Sanity field, local content module, hard-coded JSX, etc.).

This map will live in a Markdown file so it can later be used to remap copy by source location.

⸻

2. Scope & Inputs
	•	The root page is the file the user indicates (either:
	•	the currently open file in VS Code, e.g. src/app/bespoke/page.tsx, or
	•	a path explicitly given in the prompt).
	•	Treat that file as the entry point for the page’s React tree.

From that root:
	•	Follow imports into components that are actually rendered by that page.
	•	Follow imports into content/config modules (e.g. src/content/...).
	•	Follow imports into Sanity query modules (e.g. src/sanity/queries/...) to understand how fields map to UI.

You are not auditing the whole app; only the tree reachable from this page.

⸻

3. High-Level Goal

For this one page, generate a frontend copy map and save it as a Markdown file in:

docs/INTERNAL PERAZZIGPT/SITE FRONTEND COPY

The file should:
	1.	Be named based on the page, e.g.:
	•	Home-Frontend-Copy.md for src/app/page.tsx
	•	Bespoke-Frontend-Copy.md for src/app/bespoke/page.tsx
	•	Service-Frontend-Copy.md for src/app/service/page.tsx
	2.	List every piece of user-facing text on that page.
	3.	For each text item, clearly specify:
	•	Source pointer (exact location).
	•	Source type (hard-coded JSX, local content module, Sanity field, fallback fixture, etc.).
	•	Rendered text, if determinable from the repo.

This is not for design or layout; it’s purely about copy.

⸻

4. What Counts as “User-Facing Text”

Include:
	•	Headings, paragraphs, lead text, blockquotes.
	•	Button text, link labels, CTAs.
	•	Section labels, badges, tags, pill labels.
	•	Helper text, hints, subtitles, microcopy.
	•	Tooltips, alerts, notices, disclaimers.
	•	Image alt text and visible captions.
	•	Chip labels, tabs, dropdown labels, etc.
	•	Static “empty state” messages or default messages that can appear on this page.

Exclude:
	•	Class names, tailwind utility strings.
	•	Analytics/event names and IDs.
	•	Internal keys, object property names, schema definitions.
	•	Purely technical messages never shown to end users.

When in doubt, if a human can see it on the page at any time, include it.

⸻

5. Source Types & How to Treat Them

When you find text, classify its source type as one of:
	•	hardcoded-jsx
Literal strings directly in JSX, e.g. <h1>The bespoke experience</h1>.
	•	hardcoded-config
Strings in local content/config modules, e.g. src/content/... objects.
	•	sanity-field
Text coming from Sanity via a query, e.g. homeSingleton.hero.tagline.
	•	sanity-with-fallback
Text coming from Sanity with a local fallback (e.g. hero.tagline ?? heroFallback.tagline).
	•	other-dynamic
Text constructed dynamically from code (template literals, t() calls, etc.) that cannot be fully resolved to a literal without runtime data.

Rules:
	•	If the exact literal string is present in the repo (e.g. fallback content or seeded content), record that as the “Rendered Text”.
	•	If the text is fully dynamic (pure Sanity field with no local example, or built from runtime data), record:
	•	the Sanity field path (e.g. sanity.homeSingleton.hero.tagline) and
	•	set “Rendered Text” to something like: Dynamic from Sanity – actual copy set in CMS.

⸻

6. Step-by-Step Tasks

6.1 Identify the Page and Component Tree
	1.	Determine the root page component:
	•	If the user indicates a path, use that.
	•	Otherwise, assume the currently open file is the page, and identify its default export.
	2.	From that root:
	•	Inspect its JSX to find all components it renders.
	•	Follow their imports into src/components/... or similar paths.
	•	Continue recursively until you’ve covered the component tree for that page.

Focus on components that clearly render user-facing content. Ignore utility-only modules (e.g. pure hooks, helpers, constants) except where they define copy.

⸻

6.2 Find Copy and Its Source Locations

For each component in this tree:
	1.	Scan the JSX for literal strings:
	•	e.g. <h2>Perazzi Bespoke</h2> → hardcoded-jsx.
	2.	Scan for props that are clearly text:
	•	e.g. <Button label="Book a fitting" />.
	•	Follow the component definition to see how label is used if necessary.
	3.	Identify content/config modules:
	•	e.g. import { heroContent } from "@/content/home/hero".
	•	Inspect these modules and record their string values as hardcoded-config.
	4.	Identify Sanity queries and fields:
	•	Find where the page calls client.fetch(...) or uses hooks like useSanityClient, fetchHome, etc.
	•	Follow imports to src/sanity/queries/... to understand which fields map to which props.
	•	Map fields to rendered JSX text, e.g. data.hero.tagline → sanity-field: homeSingleton.hero.tagline.
	5.	If Sanity fields have fall-back fixtures:
	•	e.g. hero?.tagline ?? heroFallback.tagline.
	•	Record both:
	•	The Sanity field path.
	•	The fallback fixture location and text.

For each piece of text, capture:
	•	File path: src/... full path.
	•	(If possible) Line range where it’s defined or rendered.
	•	Expression / field path: e.g. hero.tagline, homeSingleton.hero.subtitle, content.manifestoLines[0].
	•	Source type (from the list above).
	•	Rendered text (literal, or “dynamic from Sanity / runtime”).

⸻

6.3 Design a Stable “Source Pointer”

For each text item, define a stable source_pointer string that can be reused later for remapping. Format it as:

[file:<relative_file_path>] [expr:<expression_or_field_path>]

Examples:
	•	Hard-coded JSX:
	•	[file:src/components/home/hero-banner.tsx] [expr:<h1> Perazzi Bespoke </h1>]
	•	Local content module:
	•	[file:src/content/home/hero.ts] [expr:heroCopy.tagline]
	•	Sanity field:
	•	[file:src/sanity/queries/home.ts] [expr:homeSingleton.hero.tagline]
	•	Sanity field rendered in UI:
	•	[file:src/components/home/hero-banner.tsx] [expr:hero.tagline]

The exact expr text just needs to be recognizable and unique enough to be matched again later (does not have to be executable code).

⸻

7. Output File & Format

7.1 File Creation
	1.	Construct a human-friendly name for the page:
	•	Derive from the route or file name (e.g. “Home”, “Bespoke”, “ServiceHome”).
	2.	Create or overwrite a Markdown file at:

docs/INTERNAL PERAZZIGPT/SITE FRONTEND COPY/<PageName>-Frontend-Copy.md

Examples:
	•	docs/INTERNAL PERAZZIGPT/SITE FRONTEND COPY/Home-Frontend-Copy.md
	•	docs/INTERNAL PERAZZIGPT/SITE FRONTEND COPY/Bespoke-Frontend-Copy.md

Write all results into this file rather than only returning them in-chat.

⸻

7.2 Markdown Structure

Use this structure:

# <Page Name> – Frontend Copy Map

- Route / file: `<route_or_file_path>`
- Generated by: Codex
- Purpose: Map of all user-facing text and its source locations for this page.

## Summary

- Total copy items: <N>
- Source type breakdown:
  - hardcoded-jsx: <count>
  - hardcoded-config: <count>
  - sanity-field: <count>
  - sanity-with-fallback: <count>
  - other-dynamic: <count>

## Copy Items

### Item <001>

- source_pointer: `[file:src/components/home/hero-banner.tsx] [expr:hero.tagline]`
- source_type: `sanity-with-fallback`
- rendered_in:
  - `src/components/home/hero-banner.tsx:210-218`
- data_sources:
  - sanity_field: `homeSingleton.hero.tagline`
  - fallback_fixture: `src/content/home/hero.ts > heroCopy.tagline`
- rendered_text:
  - If literal is known in repo, put the exact string here, e.g.  
    `"Perazzi bespoke begins where mass production ends."`
  - If not known:  
    `Dynamic from Sanity – copy set in CMS (field: homeSingleton.hero.tagline).`

---

### Item <002>

- source_pointer: `[file:src/components/home/hero-banner.tsx] [expr:<Button> primary CTA label]`
- source_type: `hardcoded-jsx`
- rendered_in:
  - `src/components/home/hero-banner.tsx:230-235`
- data_sources:
  - n/a (hardcoded JSX)
- rendered_text:
  - `"Book a bespoke fitting"`

---

### Item <003>

- source_pointer: `[file:src/content/home/overview.ts] [expr:overviewChecks[0].label]`
- source_type: `hardcoded-config`
- rendered_in:
  - `src/components/home/ServiceOverview.tsx:120-140`
- data_sources:
  - config_module: `src/content/home/overview.ts`
- rendered_text:
  - `"Shot pattern analysis"`

...

Continue this pattern for every user-facing text item on the page.

⸻

8. Constraints & Quality Checks
	•	Do not change any code as part of this task; this is a read-only analysis and reporting task.
	•	Be exhaustive for the page: if a string can appear for a user viewing this page under normal conditions, it should be included.
	•	If you are unsure about an item (e.g. very dynamic text), include it and note the uncertainty in rendered_text.
	•	Prefer fewer, richer entries (grouping related text from the same component) over thousands of hyper-fragmented ones—but do not omit distinct strings.

⸻

9. Final Step

After writing the file:
	•	Quickly skim the generated Markdown to ensure:
	•	The page name and path at the top are correct.
	•	The counts in the summary roughly match the number of items listed.
	•	The file path under docs/INTERNAL PERAZZIGPT/SITE FRONTEND COPY/ is correct.

At that point, the frontend copy map for this page is complete and ready for later narrative and remapping work.

⸻